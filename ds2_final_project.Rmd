---
title: "final_project_airbnb"
author: "Kwangmin Kim"
date: "April 19, 2018"
output: html_document
---
##clean and tidy the airbnb data


```{r load packages}
library(tidyverse)
library(janitor)
library(stringr)
library(forcats)
library(viridis)
library(plotly)
library(ISLR)
library(caret)
library(corrplot)
library(tree)
library(rpart)
library(randomForest)
library(gbm)
library(adabag)
library(e1071)
library(MASS)
library(caret)
library(MASS)
library(corrplot)
```

```{r clean and tidy data}
airbnb_data = read_csv("./data/nyc_airbnb.zip") %>%
  clean_names()%>%
  mutate(rating = review_scores_location / 2)%>%
  dplyr::select(boro = neighbourhood_group, neighbourhood, rating, number_of_reviews, price, room_type, reviews_per_month, availability_365, calculated_host_listings_count, name, latitude, longitude)%>%
  filter(!is.na(rating),price %in% 30:500)
  

airbnb_data$boro = as.factor(airbnb_data$boro)
airbnb_data$neighbourhood = as.factor(airbnb_data$neighbourhood)
airbnb_data$room_type = as.factor(airbnb_data$room_type)
airbnb_data = na.omit(airbnb_data)
```


```{r some basic plots }
#plotly scatter plot

airbnb_data %>%
  mutate(text_label = str_c("Price: $", price, '\nRating: ', rating, '\nName: ', name)) %>% 
  plot_ly(x = ~longitude, y = ~latitude, type = "scatter", mode = "markers",
          alpha = 0.5, 
          color = ~price,
          text = ~text_label)

common_neighborhoods =
  airbnb_data %>% 
  count(neighbourhood, sort = TRUE) %>% 
  top_n(8) %>% 
  select(neighbourhood)

#neighborhood-price
inner_join(airbnb_data, common_neighborhoods,
             by = "neighbourhood") %>% 
  mutate(neighbourhood = fct_reorder(neighbourhood, price)) %>% 
  plot_ly(y = ~price, color = ~neighbourhood, type = "box",
          colors = "Set2")
#?
airbnb_data %>% 
  count(neighbourhood) %>% 
  mutate(neighbourhood = fct_reorder(neighbourhood, n)) %>% 
  plot_ly(x = ~neighbourhood, y = ~n, color = ~neighbourhood, type = "bar")

#corplot
corr<-airbnb_data%>%
  dplyr::select(-boro , -neighbourhood, -room_type, -name, -latitude, -longitude)
corrplot(cor(corr), method="shade",shade.col=NA, tl.col="black", tl.srt=45)


```

```{r classification tree}
airbnb_tree_data = dplyr::select(airbnb_data, -neighbourhood, -reviews_per_month,- name, -latitude, -longitude)

set.seed(123)
n = nrow(airbnb_tree_data)
trainIndex = sample(1:n, size = round(0.5*n), replace=FALSE)
airbnb_tree_train = airbnb_tree_data[trainIndex ,]
airbnb_tree_test = airbnb_tree_data[-trainIndex ,]


#pruned tree
tree.airbnb <- tree(boro ~ ., data = airbnb_tree_train)
summary(tree.airbnb)

cv.tree.airbnb <- cv.tree(tree.airbnb, FUN = prune.misclass)
minsize=cv.tree.airbnb$size[which.min(cv.tree.airbnb$dev)]

prune.tree.airbnb <- prune.misclass(tree.airbnb, best = minsize)
summary(prune.tree.airbnb)

#pruned tree plot
plot(prune.tree.airbnb)
text(prune.tree.airbnb, pretty = 0)

#prediction
predict.pruned.tree <- predict(prune.tree.airbnb, airbnb_tree_test, type='class')
table(predict.pruned.tree, airbnb_tree_test$boro)

basic.mse=mean(predict.pruned.tree != airbnb_tree_test$boro)
```
the optimal tree size equals to 3, the training data error rate is 0.4531. Use test dataset to predict, the error rate is 0.4448735.  

```{r bagging}
bag.airbnb <- randomForest(boro ~ ., data = airbnb_tree_train, mtry = 10, ntree = 500, importance = TRUE)
pred.bag.airbnb <- predict(bag.airbnb, newdata = airbnb_tree_test)
table(pred.bag.airbnb, airbnb_tree_test$boro )
bag.mse=mean(pred.bag.airbnb!= airbnb_tree_test$boro )
#0.4466045 test error.
varImpPlot(bag.airbnb)
#price and availability is important
```

```{r random forest}
rf.airbnb <- randomForest(boro ~ ., data = airbnb_tree_train, mtry = 5, ntree = 500, importance = TRUE)
pred.rf.airbnb <- predict(rf.airbnb, newdata = airbnb_tree_test)
table(pred.rf.airbnb, airbnb_tree_test$boro )
rf.mse=mean(pred.rf.airbnb!= airbnb_tree_test$boro )
#0.4442743 test error
varImpPlot(rf.airbnb)
##price and availability is important
```

```{r boost}
airbnb_tree_train$boro <- as.numeric(airbnb_tree_train$boro == "Manhattan") 
airbnb_tree_test$boro <- as.numeric(airbnb_tree_test$boro == "Manhattan") 
boost.airbnb = gbm(boro ~ ., data = airbnb_tree_train, distribution = "bernoulli", n.trees = 5000, interaction.depth = 4)
yhat.boost = predict(boost.airbnb, newdata = airbnb_tree_test,
n.trees = 5000, type = "response")
pred.boost.airbnb <- ifelse(yhat.boost > 0.5, 1, 0)
table(pred.boost.airbnb, airbnb_tree_test$boro)
boost.mse = (2187 + 2596)/(2187 + 4483 + 2596 + 5754)
#(2187 + 2596)/(2187 + 4483 + 2596 + 5754) =  0.318442   test error
summary(boost.airbnb)
#price is important
```


```{r comparation}
compare_df = data.frame(Boosting_MSE = boost.mse, Random_forest_MSE =rf.mse, Bagging_MSE = bag.mse, Decision_trees_MSE = basic.mse)
compare_df
```



####???????
```{r}
pcr.data=airbnb_data%>%
  select(-name, -boro , -neighbourhood, -room_type, -latitude, -longitude, price, calculated_host_listings_count, number_of_reviews, reviews_per_month, availability_365)

pr.out <- prcomp(pcr.data, scale=TRUE)
names(pr.out)

pr.out$center
# apply(USArrests, 2, mean)

pr.out$scale
# apply(USArrests, 2, sd)

pr.out$rotation


dim(pr.out$x)
head(pr.out$x)
# The kth column is the kth PC score vector (z)

biplot(pr.out, scale=0)
# scale=0: the arrows are scaled to represent the loadings


# The PCs are only unique up to a sign change
pr.out$rotation=-pr.out$rotation
pr.out$x=-pr.out$x
biplot(pr.out, scale=0)


pr.out$sdev
# the standard deviation of each PC

pr.var=pr.out$sdev^2
pr.var
# variance explained by each PC


pve=pr.var/sum(pr.var)
pve
# PVE

plot(pve, xlab="Principal Component", ylab="Proportion of Variance Explained", ylim=c(0,1),type='b')
plot(cumsum(pve), xlab="Principal Component", ylab="Cumulative Proportion of Variance Explained", ylim=c(0,1),type='b')
a=c(1,2,8,-3)
cumsum(a)
```

```{r}

num.data=airbnb_data%>%
  select(price, reviews_per_month)

km.out <- kmeans(num.data,2,nstart=20)
# trying several random starts (nstart> 1) is often recommended
km.out$cluster
plot(num.data, col=(km.out$cluster+1), 
     main="K-Means Clustering Results with K=2", 
     xlab="", ylab="", pch=20, cex=2)


km.out <- kmeans(x,3,nstart=20)
plot(num.data, col=(km.out$cluster+1), 
     main="K-Means Clustering Results with K=3", 
     xlab="", ylab="", pch=20, cex=2)

# Total within-cluster sum of squares

km.out=kmeans(x,3,nstart=20)
km.out$tot.withinss
```

