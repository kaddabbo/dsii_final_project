---
title: "final_project_airbnb"
author: "Kwangmin Kim"
date: "April 19, 2018"
output: html_document
---
##clean and tidy the airbnb data


```{r load packages}
rm(list=ls())
library(tidyverse)
library(janitor)
library(stringr)
library(forcats)
library(viridis)
library(plotly)
library(ISLR)
library(caret)
library(corrplot)
library(tree)
library(rpart)
library(glmnet)
library(randomForest)
library(gbm)
library(adabag)
library(e1071)
library(MASS)
library(pROC)
```

```{r clean and tidy data}
airbnb_initial = read_csv("./data/nyc_airbnb.zip") 

airbnb_data = airbnb_initial%>%
  clean_names()%>%
  mutate(rating = review_scores_location / 2)%>%
  dplyr::select(boro = neighbourhood_group, neighbourhood, rating, number_of_reviews, price, room_type, reviews_per_month, availability_365, calculated_host_listings_count, name, latitude, longitude)%>%
  filter(!is.na(rating),price %in% 30:500)
  
airbnb_data$boro = as.factor(airbnb_data$boro)
airbnb_data$neighbourhood = as.factor(airbnb_data$neighbourhood)
airbnb_data$room_type = as.factor(airbnb_data$room_type)
airbnb_data = na.omit(airbnb_data)


airbnb = airbnb_initial %>%
  clean_names() %>%
  dplyr::select(-name, -host_id, -host_name, -latitude, -longitude, -last_review)

airbnb = airbnb[c(3,4,2,9,5,6,7,8,10,11,1)]
airbnb[, 3:4][is.na(airbnb[, 3:4])] = 0

airbnb$neighbourhood_group = as.numeric(as.factor(airbnb$neighbourhood_group))
airbnb$neighbourhood = as.numeric(as.factor(airbnb$neighbourhood))
airbnb$room_type = as.numeric(as.factor(airbnb$room_type))
```


```{r some basic plots }
#plotly scatter plot

airbnb_data %>%
  mutate(text_label = str_c("Price: $", price, '\nRating: ', rating, '\nName: ', name)) %>% 
  plot_ly(x = ~longitude, y = ~latitude, type = "scatter", mode = "markers",
          alpha = 0.5, 
          color = ~price,
          text = ~text_label)

common_neighborhoods = airbnb_data %>% 
  count(neighbourhood, sort = TRUE) %>% 
  top_n(8) %>% 
  dplyr::select(neighbourhood)

#neighborhood-price
inner_join(airbnb_data, common_neighborhoods,
             by = "neighbourhood") %>% 
  mutate(neighbourhood = fct_reorder(neighbourhood, price)) %>% 
  plot_ly(y = ~price, color = ~neighbourhood, type = "box",
          colors = "Set2")
#?
airbnb_data %>% 
  count(neighbourhood) %>% 
  mutate(neighbourhood = fct_reorder(neighbourhood, n)) %>% 
  plot_ly(x = ~neighbourhood, y = ~n, color = ~neighbourhood, type = "bar")

```

```{r}
#corplot
corr<-airbnb_data%>%
  dplyr::select(-boro , -neighbourhood, -room_type, -name, -latitude, -longitude)
corrplot(cor(corr), method="square",shade.col=NA, tl.col="black", tl.srt=45)

corrplot(cor(airbnb), method = "square", shade.col = NA)
```



```{r lasso}
numeric_data = airbnb_data%>%
  dplyr::select(price,everything(),-boro, -neighbourhood, -room_type, -name, -longitude, -latitude)

plot(numeric_data$price)
featurePlot(x=numeric_data[,2:5],y=numeric_data$price, plot = 'pairs')

#splitting data into train and test
sample_size=floor(0.75*nrow(numeric_data))

set.seed(1)

sample_air = sample(seq_len(nrow(numeric_data)), size = sample_size)
train = numeric_data[sample_air, ]
test = numeric_data[-sample_air, ]

#LSE on the traing data
ln_model = lm(price~., data=train)
pred_data = predict(ln_model, test)
test_error = mean((pred_data-test$price)^2)
test_error

#ridge regression
x_test = model.matrix(price~.,train)[,-1]
y_test = train$price
grid_ridge = 10^seq(10.,-5, length = 1000)

ridge_model = glmnet(x_test,y_test,alpha=0,lambda = grid_ridge)
cv.out = cv.glmnet(x_test,y_test,alpha=0, lambda = grid_ridge,
                   type.measure = "mse")
plot(cv.out)
best_lambda = cv.out$lambda.min
round(best_lambda,3)

best_ridge_mod = glmnet(x_test,y_test,alpha=0,lambda = best_lambda)

reg_pred=predict(best_ridge_mod ,s=best_lambda,newx=x_test)

test_error2= 
mean((reg_pred-y_test)^2);test_error2
```



```{r lasso}
set.seed(2)

grid_lasso = exp(seq(1,-8,length=100))
lasso_mod = glmnet(x_test,y_test,alpha=1,lambda= grid_lasso)

cv.out2 = cv.glmnet(x_test,y_test,alpha=1,lambda= grid_lasso)
best_lambda2 = cv.out2$lambda_min

plot(cv.out2)

pred_lasso = predict(lasso_mod ,s=best_lambda2, newx=x_test)
test_error3 = mean((pred_lasso-y_test)^2);test_error3


coefficients = predict(lasso_mod, s=best_lambda2, type="coefficients") %>%
                as.matrix()
non_zero_coeff = coefficients[coefficients[,1] != 0,]
non_zero_coeff%>% knitr::kable()
```

```{r LDA QDA}
set.seed(4)

train_lq = sample(1:dim(airbnb)[1], 15000, replace = FALSE)

ctrl = trainControl(method = "cv",
                     summaryFunction = twoClassSummary,
                     classProbs = TRUE)

lda.fit = lda(neighbourhood_group ~ ., data = airbnb, subset = train_lq)

lda.pred = predict(lda.fit, newdata = airbnb[-train_lq,])

#roc.lda = roc(airbnb$neighbourhood_group[-train_lq], lda.pred$posterior[,2])
#plot(roc.lda, legacy.axes = TRUE)


#ldafit1 = train(x = airbnb[,-1],
#                 y = airbnb$neighbourhood_group,
#                 method = "lda",
#                 preProc = c("center","scale"),
#                 metric = "ROC",
#                 trControl = ctrl)


#qda.fit = qda(price ~ Lag1+Lag2, data = airbnb ,subset = train_ql)
```

```{r classification tree}
airbnb_tree_data = dplyr::select(airbnb_data, -neighbourhood, -reviews_per_month,- name, -latitude, -longitude)

set.seed(123)
n = nrow(airbnb_tree_data)
trainIndex = sample(1:n, size = round(0.5*n), replace=FALSE)
airbnb_tree_train = airbnb_tree_data[trainIndex ,]
airbnb_tree_test = airbnb_tree_data[-trainIndex ,]


#pruned tree
tree.airbnb <- tree(boro ~ ., data = airbnb_tree_train)
summary(tree.airbnb)

cv.tree.airbnb <- cv.tree(tree.airbnb, FUN = prune.misclass)
minsize=cv.tree.airbnb$size[which.min(cv.tree.airbnb$dev)]

prune.tree.airbnb <- prune.misclass(tree.airbnb, best = minsize)
summary(prune.tree.airbnb)

#pruned tree plot
plot(prune.tree.airbnb)
text(prune.tree.airbnb, pretty = 0)

#prediction
predict.pruned.tree <- predict(prune.tree.airbnb, airbnb_tree_test, type='class')
table(predict.pruned.tree, airbnb_tree_test$boro)

basic.mse=mean(predict.pruned.tree != airbnb_tree_test$boro)
```
the optimal tree size equals to 3, the training data error rate is 0.4531. Use test dataset to predict, the error rate is 0.4448735.  

```{r bagging}
bag.airbnb <- randomForest(boro ~ ., data = airbnb_tree_train, mtry = 10, ntree = 500, importance = TRUE)
pred.bag.airbnb <- predict(bag.airbnb, newdata = airbnb_tree_test)
table(pred.bag.airbnb, airbnb_tree_test$boro )
bag.mse=mean(pred.bag.airbnb!= airbnb_tree_test$boro )
#0.4466045 test error.
varImpPlot(bag.airbnb)
#price and availability is important
```

```{r random forest}
rf.airbnb <- randomForest(boro ~ ., data = airbnb_tree_train, mtry = 5, ntree = 500, importance = TRUE)
pred.rf.airbnb <- predict(rf.airbnb, newdata = airbnb_tree_test)
table(pred.rf.airbnb, airbnb_tree_test$boro )
rf.mse=mean(pred.rf.airbnb!= airbnb_tree_test$boro )
#0.4442743 test error
varImpPlot(rf.airbnb)
##price and availability is important
```

```{r boost}
airbnb_tree_train$boro <- as.numeric(airbnb_tree_train$boro == "Manhattan") 
airbnb_tree_test$boro <- as.numeric(airbnb_tree_test$boro == "Manhattan") 
boost.airbnb = gbm(boro ~ ., data = airbnb_tree_train, distribution = "bernoulli", n.trees = 5000, interaction.depth = 4)
yhat.boost = predict(boost.airbnb, newdata = airbnb_tree_test,
n.trees = 5000, type = "response")
pred.boost.airbnb <- ifelse(yhat.boost > 0.5, 1, 0)
table(pred.boost.airbnb, airbnb_tree_test$boro)
boost.mse = (2187 + 2596)/(2187 + 4483 + 2596 + 5754)
#(2187 + 2596)/(2187 + 4483 + 2596 + 5754) =  0.318442   test error
summary(boost.airbnb)
#price is important
```


```{r comparation}
compare_df = data.frame(Boosting_MSE = boost.mse, Random_forest_MSE =rf.mse, Bagging_MSE = bag.mse, Decision_trees_MSE = basic.mse)
compare_df
```
